---
layout : post
category : manage
tags : [Linux]
title : Linux 系统优化之CPU
---



### 1.cpu 性能评估
 
	Cpu是影响Linux性能的主要因素之一，下面先介绍几个查看CPU性能的命令。
#### 1.1 vmstat 命令

	该命令可以显示关于系统各种资源之间相关性能的简要信息，这里我们主要用它来看CPU的一个负载情况。
	
	下面是vmstat命令在某个系统的输出结果：
	
	[root@node1 ~]# vmstat 2 3
	procs -----------memory----------  ---swap--  -----io---- --system--  -----cpu------
	r  b   swpd   free   buff  cache   si   so    bi    bo    in    cs    us sy  id  wa st
	0  0    0    162240   8304  67032   0    0    13    21   1007   23     0  1  98  0  0
	0  0    0    162240   8304  67032   0    0     1     0   1010   20     0  1  100 0  0
	0  0    0    162240   8304  67032   0    0     1     1   1009   18     0  1  99  0  0
	
	对上面每项的输出解释如下：
	procs
	
	r列表示运行和等待cpu时间片的进程数，这个值如果长期大于系统CPU的个数，说明CPU不足，需要增加CPU。
	b列表示在等待资源的进程数，比如正在等待I/O、或者内存交换等。
	
	memory
	swpd列表示切换到内存交换区的内存数量（以k为单位）。如果swpd的值不为0，或者比较大，只要si、so的值长期为0，这种情况下一般不用担心，不会影响系统性能。
	free列表示当前空闲的物理内存数量（以k为单位）
	buff列表示buffers cache的内存数量，一般对块设备的读写才需要缓冲。
	cache列表示page cached的内存数量，一般作为文件系统cached，频繁访问的文件都会被cached，如果cache值较大，说明cached的文件数较多，如果此时IO中bi比较小，说明文件系统效率比较好。
	
	swap
	si列表示由磁盘调入内存，也就是内存进入内存交换区的数量。
	so列表示由内存调入磁盘，也就是内存交换区进入内存的数量。
	一般情况下，si、so的值都为0，如果si、so的值长期不为0，则表示系统内存不足。需要增加系统内存。
	
	IO项显示磁盘读写状况
	Bi列表示从块设备读入数据的总量（即读磁盘）（每秒kb）。
	Bo列表示写入到块设备的数据总量（即写磁盘）（每秒kb）
	这里我们设置的bi+bo参考值为1000，如果超过1000，而且wa值较大，则表示系统磁盘IO有问题，应该考虑提高磁盘的读写性能。
	
	system 显示采集间隔内发生的中断数
	in列表示在某一时间间隔中观测到的每秒设备中断数。
	cs列表示每秒产生的上下文切换次数。
	上面这2个值越大，会看到由内核消耗的CPU时间会越多。
	
	CPU项显示了CPU的使用状态，此列是我们关注的重点。
	us列显示了用户进程消耗的CPU 时间百分比。us的值比较高时，说明用户进程消耗的cpu时间多，但是如果长期大于50%，就需要考虑优化程序或算法。
	sy列显示了内核进程消耗的CPU时间百分比。Sy的值较高时，说明内核消耗的CPU资源很多。
	根据经验，us+sy的参考值为80%，如果us+sy大于 80%说明可能存在CPU资源不足。
	id 列显示了CPU处在空闲状态的时间百分比。
	wa列显示了IO等待所占用的CPU时间百分比。wa值越高，说明IO等待越严重，根据经验，wa的参考值为20%，如果wa超过20%，说明IO等待严重，引起IO等待的原因可能是磁盘大量随机读写造成的，也可能是磁盘或者磁盘控制器的带宽瓶颈造成的（主要是块操作）。
	综上所述，在对CPU的评估中，需要重点注意的是procs项r列的值和CPU项中us、sy和id列的值。

#### 1.2  sar 命令
	检查CPU性能的第二个工具是sar，sar功能很强大，可以对系统的每个方面进行单独的统计，但是使用sar命令会增加系统开销，不过这些开销是可以评估的，对系统的统计结果不会有很大影响。
	
	下面是sar命令对某个系统的CPU统计输出：
	[root@webserver ~]# sar -u 3 5
	Linux 2.6.9-42.ELsmp (webserver)        11/28/2008      _i686_  (8 CPU)

	11:41:24 AM     CPU     %user     %nice   %system   %iowait    %steal     %idle
	11:41:27 AM     all      0.88      0.00      0.29      0.00      0.00     98.83
	11:41:30 AM     all      0.13      0.00      0.17      0.21      0.00     99.50
	11:41:33 AM     all      0.04      0.00      0.04      0.00      0.00     99.92
	11:41:36 AM     all      0.29      0.00      0.13      0.00      0.00     99.58
	11:41:39 AM     all      0.38      0.00      0.17      0.04      0.00     99.41
	Average:        all      0.34      0.00      0.16      0.05      0.00     99.45
	
	对上面每项的输出解释如下：
	%user列显示了用户进程消耗的CPU 时间百分比。
	%nice列显示了运行正常进程所消耗的CPU 时间百分比。
	%system列显示了系统进程消耗的CPU时间百分比。
	%iowait列显示了IO等待所占用的CPU时间百分比
	%steal列显示了在内存相对紧张的环境下pagein强制对不同的页面进行的steal操作 。
	%idle列显示了CPU处在空闲状态的时间百分比。
	
	这个输出是对系统整体CPU使用状况的统计，每项的输出都非常直观，并且最后一行Average是个汇总行，是上面统计信息的一个平均值。
	需要注意的一点是：第一行的统计信息中包含了sar本身的统计消耗，所以%user列的值会偏高一点，不过，这不会对统计结果产生多大影响。
	在一个多CPU的系统中，如果程序使用了单线程，会出现这么一个现象，CPU的整体使用率不高，但是系统应用却响应缓慢，这可能是由于程序使用单线程的原因，单线程只使用一个CPU，导致这个CPU占用率为100%，无法处理其它请求，而其它的CPU却闲置，这就导致 了整体CPU使用率不高，而应用缓慢 现象的发生 。
	针对这个问题，可以对系统的每个CPU分开查询，统计每个CPU的使用情况：
	
	[root@webserver ~]# sar -P 0 3 5
	Linux 2.6.9-42.ELsmp (webserver)        11/29/2008      _i686_  (8 CPU)

	06:29:33 PM     CPU     %user     %nice   %system   %iowait    %steal     %idle
	06:29:36 PM       0      3.00      0.00      0.33      0.00      0.00     96.67
	06:29:39 PM       0      0.67      0.00      0.33      0.00      0.00     99.00
	06:29:42 PM       0      0.00      0.00      0.33      0.00      0.00     99.67
	06:29:45 PM       0      0.67      0.00      0.33      0.00      0.00     99.00
	06:29:48 PM       0      1.00      0.00      0.33      0.33      0.00     98.34
	Average:          0      1.07      0.00      0.33      0.07      0.00     98.53
	
	这个输出是对系统的第一颗CPU的信息统计，需要注意的是，sar中对CPU的计数是从0开始的，因此，“sar -P 0 3 5”表示对系统的第一颗CPU进行信息统计，“sar -P 4 3 5”则表示对系统的第五颗CPU进行统计。依次类推。可以看出，上面的系统有八颗CPU。

#### 1.3 iostat 命令
	iostat指令主要用于统计磁盘IO状态，但是也能查看CPU的使用信息，它的局限性是只能显示系统所有CPU的平均信息，看下面的一个输出：
	
	[root@webserver ~]# iostat  -c
	Linux 2.6.9-42.ELsmp (webserver)        11/29/2008      _i686_  (8 CPU)

	avg-cpu:  %user   %nice   %system  %iowait  %steal   %idle
				2.52    0.00    0.30     0.24     0.00    96.96
	
	在这里，使用了“-c”参数，只显示系统CPU的统计信息，输出中每项代表的含义与sar命令的输出项完全相同，不再详述。

#### 1.4 uptime 命令
	
	uptime是监控系统性能最常用的一个命令，主要用来统计系统当前的运行状况，输出的信息依次为：系统现在的时间、系统从上次开机到现在运行了多长时间、系统目前有多少登陆用户、系统在一分钟内、五分钟内、十五分钟内的平均负载。看下面的一个输出：
	
	[root@webserver ~]# uptime
	18:52:11 up 27 days, 19:44,  2 users,  load average: 0.12, 0.08, 0.08
	
	这里需要注意的是load average这个输出值，这三个值的大小一般不能大于系统CPU的个数，例如，本输出中系统有8个CPU,如果load average的三个值长期大于8时，说明CPU很繁忙，负载很高，可能会影响系统性能，但是偶尔大于8时，倒不用担心，一般不会影响系统性能。相反，如果load average的输出值小于CPU的个数，则表示CPU还有空闲的时间片，比如本例中的输出，CPU是非常空闲的。
